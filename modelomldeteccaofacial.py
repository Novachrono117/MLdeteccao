# -*- coding: utf-8 -*-
"""modeloMLdeteccaofacial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WY3L92NpzsEFPmsCJfbbVZNRZuJpL6ZN

Modelo ML para detecção facial
"""

!pip install ultralytics

import pandas as pd
import io
import scipy.io
import os
import cv2
import numpy as np
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
import torch
import torch.nn as nn
import xml.etree.ElementTree as ET
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms, utils

from google.colab import drive
drive.mount('/content/mydrive')

dataset_path = '/content/mydrive/MyDrive/faces/humans'

import torch

def carregar_dados(dataset_path):
  imagens = []
  caixas_delimitadoras = []

  model = torch.hub.load('ultralytics/yolov5', 'yolov5s')

  for nome_arquivo in os.listdir(dataset_path):
    if nome_arquivo.endswith(('.jpg', '.jpeg', '.png')):
      imagem = cv2.imread(os.path.join(dataset_path, nome_arquivo))
      imagens.append(imagem)

      results = model(imagem)

      detections = results.pandas().xyxy[0]
      for _, detection in detections.iterrows():
        xmin = int(detection['xmin'])
        ymin = int(detection['ymin'])
        xmax = int(detection['xmax'])
        ymax = int(detection['ymax'])
        caixas_delimitadoras.append([xmin, ymin, xmax, ymax])

  return imagens, caixas_delimitadoras

from sklearn.model_selection import train_test_split

X_train , X_test, y_train, y_test = train_test_split(imagens, caixas_delimitadoras, test_size=0.2, random_state=42)

model = tf.keras.models.Sequential([
   tf.keras.layers.Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 3)),
   tf.keras.layers.MaxPooling2D((2, 2)),
   tf.keras.layers.Conv2D(64, (3, 3), activation='relu'),
   tf.keras.layers.MaxPooling2D((2, 2)),
   tf.keras.layers.Flatten(),
   tf.keras.layers.Dense(1, activation='sigmoid')
 ])


model.compile(optimizer='adam',
               loss='sparse_categorical_crossentropy',
               metrics=['accuracy'])


model.summary()

# Criação do modelo
model = Sequential([
  Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 3)),
  MaxPooling2D((2, 2)),
  Conv2D(64, (3, 3), activation='relu'),
  MaxPooling2D((2, 2)),
  Flatten(),
  Dense(1, activation='sigmoid')
])


model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy','loss'])


model.summary()

model.fit(X_train, y_train, epochs=10)
test_loss, test_acc = model.evaluate(X_test, y_test)
 print('accuracy:', test_acc)